<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Vocabulary List</title>
<style>
    * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
    }
    
    body { 
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
        max-width: 600px;
        margin: 0 auto;
        padding: 40px 20px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
        transition: background 0.3s;
    }
    
    body.night-mode {
        background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
    }
    
    .theme-toggle {
        position: fixed;
        top: 20px;
        right: 20px;
        background: rgba(255, 255, 255, 0.2);
        border: none;
        border-radius: 50%;
        width: 50px;
        height: 50px;
        cursor: pointer;
        font-size: 24px;
        display: flex;
        align-items: center;
        justify-content: center;
        backdrop-filter: blur(10px);
        transition: all 0.3s;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        z-index: 1001;
    }
    
    .theme-toggle:hover {
        transform: scale(1.1) rotate(15deg);
        background: rgba(255, 255, 255, 0.3);
    }
    
    h2 {
        color: white;
        margin-bottom: 20px;
        font-size: 24px;
        font-weight: 600;
        text-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    .card {
        background: white;
        border-radius: 16px;
        padding: 24px;
        margin-bottom: 24px;
        box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        transition: all 0.3s;
    }
    
    body.night-mode .card {
        background: #2a2a3e;
        box-shadow: 0 10px 30px rgba(0,0,0,0.5);
    }
    
    input { 
        padding: 12px 16px;
        width: 100%;
        margin-bottom: 12px;
        box-sizing: border-box;
        font-size: 15px;
        border: 2px solid #e0e0e0;
        border-radius: 10px;
        transition: all 0.3s;
        font-family: inherit;
        background: white;
        color: #333;
    }
    
    body.night-mode input {
        background: #1a1a2e;
        border-color: #3a3a4e;
        color: #e0e0e0;
    }
    
    input:focus {
        outline: none;
        border-color: #667eea;
        box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
    }
    
    body.night-mode input:focus {
        border-color: #8b9eff;
        box-shadow: 0 0 0 3px rgba(139, 158, 255, 0.2);
    }
    
    button { 
        padding: 12px 24px;
        cursor: pointer;
        font-size: 15px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        border-radius: 10px;
        font-weight: 600;
        transition: all 0.3s;
        box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
    }
    
    button:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
    }
    
    button:active {
        transform: translateY(0);
    }
    
    .item {
        padding: 16px;
        border-bottom: 1px solid #f0f0f0;
        display: flex;
        justify-content: space-between;
        align-items: center;
        transition: all 0.3s;
        border-radius: 8px;
        margin-bottom: 4px;
        color: #333;
    }
    
    body.night-mode .item {
        border-bottom: 1px solid #3a3a4e;
        color: #e0e0e0;
    }
    
    .item:hover {
        background-color: #f8f9ff;
    }
    
    body.night-mode .item:hover {
        background-color: #3a3a4e;
    }
    
    .item.highlight {
        background: linear-gradient(90deg, #fff3cd 0%, #fffaeb 100%);
        border-left: 4px solid #ffc107;
        padding-left: 12px;
        box-shadow: 0 2px 8px rgba(255, 193, 7, 0.3);
    }
    
    .item:last-child {
        border-bottom: none;
    }
    
    .term { 
        font-weight: 600;
        color: #667eea;
        font-size: 16px;
    }
    
    .item button {
        padding: 6px 14px;
        font-size: 13px;
        background: #ff4757;
        box-shadow: 0 2px 8px rgba(255, 71, 87, 0.3);
        margin-left: 6px;
    }
    
    .item button:hover {
        background: #ff3838;
        box-shadow: 0 4px 12px rgba(255, 71, 87, 0.5);
    }
    
    .item button.edit-btn {
        background: linear-gradient(135deg, #4dabf7 0%, #339af0 100%);
        box-shadow: 0 2px 8px rgba(77, 171, 247, 0.3);
    }
    
    .item button.edit-btn:hover {
        background: linear-gradient(135deg, #339af0 0%, #228be6 100%);
        box-shadow: 0 4px 12px rgba(77, 171, 247, 0.5);
    }
    
    .button-group {
        display: flex;
        gap: 6px;
    }
    
    .input-container { 
        position: relative;
        margin-bottom: 12px;
    }
    
    .dropdown {
        position: absolute;
        top: 100%;
        left: 0;
        right: 0;
        background: white;
        border: 2px solid #667eea;
        border-top: none;
        border-radius: 0 0 10px 10px;
        max-height: 250px;
        overflow-y: auto;
        display: none;
        z-index: 1000;
        box-shadow: 0 8px 24px rgba(102, 126, 234, 0.3);
        margin-top: -10px;
    }
    
    body.night-mode .dropdown {
        background: #1a1a2e;
        border-color: #8b9eff;
        box-shadow: 0 8px 24px rgba(139, 158, 255, 0.3);
    }
    
    .dropdown-item {
        padding: 14px 16px;
        cursor: pointer;
        border-bottom: 1px solid #f0f0f0;
        transition: all 0.2s;
    }
    
    body.night-mode .dropdown-item {
        border-bottom: 1px solid #3a3a4e;
    }
    
    .dropdown-item:last-child {
        border-bottom: none;
    }
    
    .dropdown-item:hover {
        background: linear-gradient(90deg, #e8f0fe 0%, #f0e7ff 100%);
        padding-left: 20px;
    }
    
    .dropdown-item.active {
        background: linear-gradient(90deg, #e8f0fe 0%, #f0e7ff 100%);
        padding-left: 20px;
    }
    
    body.night-mode .dropdown-item:hover {
        background: linear-gradient(90deg, #2a2a4e 0%, #3a3a5e 100%);
        padding-left: 20px;
    }
    
    .dropdown-item .match-term { 
        font-weight: 600;
        color: #667eea;
        font-size: 15px;
    }
    
    body.night-mode .dropdown-item .match-term {
        color: #8b9eff;
    }
    
    .dropdown-item .match-translation { 
        color: #666;
        margin-left: 8px;
        font-size: 14px;
    }
    
    body.night-mode .dropdown-item .match-translation {
        color: #b0b0b0;
    }
    
    .empty-state {
        text-align: center;
        padding: 40px 20px;
        color: #999;
        font-style: italic;
    }
    
    body.night-mode .empty-state {
        color: #666;
    }
    
    .tag-input-container {
        display: flex;
        gap: 8px;
        margin-bottom: 12px;
        align-items: center;
        position: relative;
    }
    
    .tag-input-container input {
        margin-bottom: 0;
        flex: 1;
    }
    
    .tag-dropdown {
        position: absolute;
        top: 100%;
        left: 0;
        right: 0;
        background: white;
        border: 2px solid #667eea;
        border-top: none;
        border-radius: 0 0 10px 10px;
        max-height: 150px;
        overflow-y: auto;
        display: none;
        z-index: 1000;
        box-shadow: 0 8px 24px rgba(102, 126, 234, 0.3);
        margin-top: -10px;
    }

    /* Modal Styles */
    .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.7);
        display: none;
        justify-content: center;
        align-items: center;
        z-index: 2000;
        backdrop-filter: blur(5px);
    }
    
    .modal {
        background: white;
        padding: 24px;
        border-radius: 16px;
        max-width: 500px;
        width: 90%;
        box-shadow: 0 20px 50px rgba(0,0,0,0.3);
        animation: modalSlideIn 0.3s cubic-bezier(0.16, 1, 0.3, 1);
    }
    
    body.night-mode .modal {
        background: #2a2a3e;
        color: #e0e0e0;
    }
    
    @keyframes modalSlideIn {
        from { transform: translateY(20px); opacity: 0; }
        to { transform: translateY(0); opacity: 1; }
    }
    
    .comparison-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 16px;
        margin: 20px 0;
    }
    
    .comparison-col h4 {
        margin-bottom: 12px;
        font-size: 14px;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        color: #667eea;
    }
    
    .comparison-box {
        background: #f8f9ff;
        padding: 12px;
        border-radius: 8px;
        border: 1px solid #e0e0e0;
    }
    
    body.night-mode .comparison-box {
        background: #1a1a2e;
        border-color: #3a3a4e;
    }
    
    .comp-field {
        margin-bottom: 8px;
    }
    
    .comp-label {
        font-size: 12px;
        color: #888;
        margin-bottom: 2px;
    }
    
    .comp-value {
        font-weight: 500;
        word-break: break-word;
        font-size: 14px;
    }
    
    .modal-actions {
        display: flex;
        gap: 10px;
        justify-content: flex-end;
        margin-top: 24px;
        flex-wrap: wrap;
    }
    
    .btn-secondary {
        background: #e0e0e0;
        color: #333;
        box-shadow: none;
    }
    
    .btn-secondary:hover {
        background: #d0d0d0;
    }
    
    body.night-mode .btn-secondary {
        background: #3a3a4e;
        color: #e0e0e0;
    }
    
    .btn-danger {
        background: #ff4757;
        box-shadow: 0 4px 12px rgba(255, 71, 87, 0.3);
    }
    
    .btn-danger:hover {
        background: #ff3838;
    }
    
    body.night-mode .tag-dropdown {
        background: #1a1a2e;
        border-color: #8b9eff;
        box-shadow: 0 8px 24px rgba(139, 158, 255, 0.3);
    }
    
    .tag-dropdown-item {
        color: #667eea;
        padding: 10px 12px;
        cursor: pointer;
        border-bottom: 1px solid #f0f0f0;
        transition: all 0.2s;
        display: flex;
        align-items: center;
        gap: 8px;
    }
    
    body.night-mode .tag-dropdown-item {
        border-bottom: 1px solid #3a3a4e;
    }
    
    .tag-dropdown-item:last-child {
        border-bottom: none;
    }
    
    .tag-dropdown-item:hover {
        background: linear-gradient(90deg, #e8f0fe 0%, #f0e7ff 100%);
        padding-left: 16px;
    }
    
    body.night-mode .tag-dropdown-item:hover {
        background: linear-gradient(90deg, #2a2a4e 0%, #3a3a5e 100%);
        padding-left: 16px;
    }
    
    .tag-dropdown-item.active {
        background: linear-gradient(90deg, #e8f0fe 0%, #f0e7ff 100%);
        padding-left: 16px;
    }
    
    .tag-dropdown-item .mini-tag {
        display: inline-block;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        flex-shrink: 0;
    }
    
    .export-import-container {
        display: flex;
        gap: 8px;
        margin-top: 16px;
        padding-top: 16px;
        border-top: 2px solid #f0f0f0;
    }
    
    body.night-mode .export-import-container {
        border-top-color: #3a3a4e;
    }
    
    .export-import-container button {
        flex: 1;
        padding: 10px 16px;
        font-size: 14px;
        background: linear-gradient(135deg, #20c997 0%, #12b886 100%);
        box-shadow: 0 4px 12px rgba(32, 201, 151, 0.4);
    }
    
    .export-import-container button:hover {
        box-shadow: 0 6px 20px rgba(32, 201, 151, 0.6);
    }
    
    .export-import-container button.import-btn {
        background: linear-gradient(135deg, #4dabf7 0%, #339af0 100%);
        box-shadow: 0 4px 12px rgba(77, 171, 247, 0.4);
    }
    
    .export-import-container button.import-btn:hover {
        box-shadow: 0 6px 20px rgba(77, 171, 247, 0.6);
    }
    
    #importFile {
        display: none;
    }
    
    .import-status {
        margin-top: 12px;
        padding: 12px;
        border-radius: 8px;
        font-size: 14px;
        text-align: center;
        display: none;
    }
    
    .import-status.success {
        background: #d3f9d8;
        color: #2b8a3e;
        display: block;
    }
    
    body.night-mode .import-status.success {
        background: #2b8a3e;
        color: #d3f9d8;
    }
    
    .import-status.error {
        background: #ffe3e3;
        color: #c92a2a;
        display: block;
    }
    
    body.night-mode .import-status.error {
        background: #c92a2a;
        color: #ffe3e3;
    }
    
    .color-picker {
        display: flex;
        gap: 6px;
        padding: 8px;
        background: rgba(0,0,0,0.05);
        border-radius: 10px;
        flex-wrap: wrap;
    }
    
    body.night-mode .color-picker {
        background: rgba(255,255,255,0.05);
    }
    
    .color-option {
        width: 32px;
        height: 32px;
        border-radius: 50%;
        cursor: pointer;
        border: 3px solid transparent;
        transition: all 0.3s;
        position: relative;
    }
    
    .color-option:hover {
        transform: scale(1.15);
    }
    
    .color-option.selected {
        border-color: white;
        box-shadow: 0 0 0 2px rgba(0,0,0,0.2);
        transform: scale(1.2);
    }
    
    body.night-mode .color-option.selected {
        box-shadow: 0 0 0 2px rgba(255,255,255,0.3);
    }
    
    .color-option.red { background: linear-gradient(135deg, #ff6b6b 0%, #ee5a6f 100%); }
    .color-option.blue { background: linear-gradient(135deg, #4dabf7 0%, #339af0 100%); }
    .color-option.green { background: linear-gradient(135deg, #51cf66 0%, #40c057 100%); }
    .color-option.yellow { background: linear-gradient(135deg, #ffd43b 0%, #fab005 100%); }
    .color-option.purple { background: linear-gradient(135deg, #b197fc 0%, #9775fa 100%); }
    .color-option.orange { background: linear-gradient(135deg, #ff922b 0%, #fd7e14 100%); }
    .color-option.pink { background: linear-gradient(135deg, #f06595 0%, #e64980 100%); }
    .color-option.teal { background: linear-gradient(135deg, #20c997 0%, #12b886 100%); }
    
    .tag {
        display: inline-block;
        padding: 4px 10px;
        border-radius: 12px;
        font-size: 12px;
        font-weight: 600;
        margin-left: 8px;
        color: white;
        text-shadow: 0 1px 2px rgba(0,0,0,0.2);
    }
    
    .tag.red, .filter-tag.red { background: linear-gradient(135deg, #ff6b6b 0%, #ee5a6f 100%); }
    .tag.blue, .filter-tag.blue { background: linear-gradient(135deg, #4dabf7 0%, #339af0 100%); }
    .tag.green, .filter-tag.green { background: linear-gradient(135deg, #51cf66 0%, #40c057 100%); }
    .tag.yellow, .filter-tag.yellow { background: linear-gradient(135deg, #ffd43b 0%, #fab005 100%); }
    .tag.purple, .filter-tag.purple { background: linear-gradient(135deg, #b197fc 0%, #9775fa 100%); }
    .tag.orange, .filter-tag.orange { background: linear-gradient(135deg, #ff922b 0%, #fd7e14 100%); }
    .tag.pink, .filter-tag.pink { background: linear-gradient(135deg, #f06595 0%, #e64980 100%); }
    .tag.teal, .filter-tag.teal { background: linear-gradient(135deg, #20c997 0%, #12b886 100%); }
    
    .filter-container {
        display: flex;
        gap: 8px;
        margin-bottom: 16px;
        flex-wrap: wrap;
    }
    
    .filter-tag {
        padding: 6px 14px;
        border-radius: 20px;
        font-size: 13px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s;
        border: 2px solid transparent;
        color: white;
    }
    
    .filter-tag.active {
        border-color: white;
        box-shadow: 0 0 0 2px rgba(255,255,255,0.3);
        transform: scale(1.05);
    }
    
    .filter-tag.all {
        background: linear-gradient(135deg, #868e96 0%, #495057 100%);
    }
    
    /* Ensure active filter tag is visible in LIGHT mode even if no color class is present */
    body:not(.night-mode) .filter-tag.active:not(.red):not(.blue):not(.green):not(.yellow):not(.purple):not(.orange):not(.pink):not(.teal):not(.all) {
        background: #e8ecff;
        color: #1f1f1f;
        border-color: #1f2937;
        box-shadow: 0 0 0 3px rgba(31, 41, 55, 0.6);
    }
    body:not(.night-mode) .filter-tag.active {
        border-color: #1f2937;
        box-shadow: 0 0 0 3px rgba(31, 41, 55, 0.6);
    }
    
    /* Scrollbar styling */
    .dropdown::-webkit-scrollbar {
        width: 8px;
    }
    
    .dropdown::-webkit-scrollbar-track {
        background: #f1f1f1;
        border-radius: 10px;
    }
    
    .dropdown::-webkit-scrollbar-thumb {
        background: #667eea;
        border-radius: 10px;
    }
</style>
</head>
<body>

<button class="theme-toggle" onclick="toggleTheme()">üåô</button>

<h2>‚ú® Add Vocabulary</h2>
<div class="card">
    <div class="input-container">
        <input id="termInput" type="text" placeholder="Term" onkeypress="handleKeyPress(event)">
        <div id="dropdown" class="dropdown"></div>
    </div>
    <div class="input-container">
        <input id="translationInput" type="text" placeholder="Translation" onkeypress="handleKeyPress(event)">
        <div id="translationDropdown" class="dropdown"></div>
    </div>
    <div class="tag-input-container">
        <input id="tagInput" type="text" placeholder="Type tag & press Enter" oninput="handleTagSearch()" onfocus="handleTagSearch()" onblur="hideTagDropdown()" onkeypress="handleKeyPress(event)">
        <div id="tagDropdown" class="tag-dropdown"></div>
    </div>
    <div id="activeTags" style="display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 12px;"></div>
    <div class="color-picker">
        <div class="color-option blue selected" data-color="blue" onclick="selectColor('blue')"></div>
        <div class="color-option red" data-color="red" onclick="selectColor('red')"></div>
        <div class="color-option green" data-color="green" onclick="selectColor('green')"></div>
        <div class="color-option yellow" data-color="yellow" onclick="selectColor('yellow')"></div>
        <div class="color-option purple" data-color="purple" onclick="selectColor('purple')"></div>
        <div class="color-option orange" data-color="orange" onclick="selectColor('orange')"></div>
        <div class="color-option pink" data-color="pink" onclick="selectColor('pink')"></div>
        <div class="color-option teal" data-color="teal" onclick="selectColor('teal')"></div>
    </div>
    <button style="margin-top: 8px;" onclick="addItem()">‚ûï</button>
</div>

<h2>ÔøΩÔøΩ Your Vocabulary</h2>
<div class="card">
    <div id="filterContainer" class="filter-container"></div>
    <div id="list"></div>
    <div class="export-import-container">
        <button onclick="exportVocabulary()">üì§ Export</button>
        <button class="import-btn" onclick="document.getElementById('importFile').click()">üì• Import</button>
    </div>
    <input type="file" id="importFile" accept=".json" onchange="importVocabulary(event)">
    <div id="importStatus" class="import-status"></div>
</div>

<script>
    let entries = [];
    let currentFilter = 'all';
    let selectedColor = 'blue';
    let currentEntryTags = [];
    let editingIndex = null;
    let termMatches = [];
    let termDropdownIndex = -1;
    let tagMatches = [];
    let tagDropdownIndex = -1;
    let translationMatches = [];
    let translationDropdownIndex = -1;
    let tagEditSelectedColor = null;
    let tagEditSuppressBlurCommit = false;

    // Load saved entries
    function loadEntries() {
        try {
            const saved = localStorage.getItem("vocab_entries");
            if (saved) {
                entries = JSON.parse(saved);
                // Migration to multi-tags
                entries.forEach(e => {
                    if (!e.tags) {
                        if (e.tag) {
                            e.tags = [{ text: e.tag, color: e.color || 'blue' }];
                        } else {
                            e.tags = [];
                        }
                        delete e.tag;
                        delete e.color;
                    }
                });
                renderList();
            }
        } catch (error) {
            console.log("Loading entries:", error);
        }
    }

    function addTag(text = null, color = null) {
        const rawInput = text || document.getElementById("tagInput").value;
        if (!rawInput) return;
        
        const tags = rawInput.split(',').map(t => t.trim()).filter(t => t);
        if (tags.length === 0) return;

        const colors = ['blue', 'red', 'green', 'yellow', 'purple', 'orange', 'pink', 'teal'];
        const useRandomColor = tags.length > 1;

        tags.forEach(tagText => {
            if (currentEntryTags.some(t => t.text === tagText)) return;
            
            let tagColor;
            if (color) {
                tagColor = color;
            } else if (useRandomColor) {
                tagColor = colors[Math.floor(Math.random() * colors.length)];
            } else {
                tagColor = selectedColor;
            }
            
            currentEntryTags.push({
                text: tagText,
                color: tagColor
            });
        });
        
        renderActiveTags();
        document.getElementById("tagInput").value = "";
        document.getElementById("tagInput").focus();
    }

    function removeTag(index) {
        currentEntryTags.splice(index, 1);
        renderActiveTags();
    }

    function renderActiveTags() {
        const container = document.getElementById("activeTags");
        container.innerHTML = "";
        currentEntryTags.forEach((t, i) => {
            const tag = document.createElement("span");
            tag.className = `tag ${t.color}`;
            tag.innerHTML = `${escapeHtml(t.text)} <span style="cursor:pointer;margin-left:4px;opacity:0.8" onclick="removeTag(${i})">√ó</span>`;
            container.appendChild(tag);
        });
    }

    async function addItem() {
        const term = document.getElementById("termInput").value.trim();
        const translation = document.getElementById("translationInput").value.trim();
        
        const pendingTag = document.getElementById("tagInput").value.trim();
        if (pendingTag) {
            addTag(pendingTag);
        }
        
        if (!term || !translation) return;

        const newEntry = { term, translation, tags: [...currentEntryTags] };

        if (editingIndex !== null) {
            // Update existing entry
            entries[editingIndex] = newEntry;
            entries.sort((a, b) => a.term.localeCompare(b.term));
            editingIndex = null;
            document.querySelector('button[onclick="addItem()"]').textContent = "‚ûï";
        } else {
            // Add new entry
            entries.push(newEntry);
            entries.sort((a, b) => a.term.localeCompare(b.term));
        }
        
        saveEntries();

        document.getElementById("termInput").value = "";
        document.getElementById("translationInput").value = "";
        document.getElementById("tagInput").value = "";
        currentEntryTags = [];
        renderActiveTags();
        selectColor('blue');
        renderList();
        renderFilters();
        document.getElementById("termInput").focus();
    }

    async function deleteItem(index) {
        // If we're editing this item, cancel the edit
        if (editingIndex === index) {
            cancelEdit();
        }
        
        entries.splice(index, 1);
        saveEntries();
        renderList();
        renderFilters();
    }
    
    function editItem(index) {
        editingIndex = index;
        const entry = entries[index];
        
        document.getElementById("termInput").value = entry.term;
        document.getElementById("translationInput").value = entry.translation;
        document.getElementById("tagInput").value = "";
        
        currentEntryTags = entry.tags ? JSON.parse(JSON.stringify(entry.tags)) : [];
        renderActiveTags();
        
        selectColor('blue');
        
        // Change button text to indicate editing mode
        document.querySelector('button[onclick="addItem()"]').textContent = "üíæ Update";
        
        // Scroll to top
        window.scrollTo({ top: 0, behavior: 'smooth' });
        
        // Focus on term input
        document.getElementById("termInput").focus();
    }
    
    function cancelEdit() {
        editingIndex = null;
        document.getElementById("termInput").value = "";
        document.getElementById("translationInput").value = "";
        document.getElementById("tagInput").value = "";
        currentEntryTags = [];
        renderActiveTags();
        selectColor('blue');
        document.querySelector('button[onclick="addItem()"]').textContent = "‚ûï";
    }

    function saveEntries() {
        try {
            localStorage.setItem("vocab_entries", JSON.stringify(entries));
            console.log("Saved successfully");
        } catch (error) {
            console.error("Error saving:", error);
        }
    }

    function renderList() {
        const list = document.getElementById("list");
        list.innerHTML = "";

        const filteredEntries = currentFilter === 'all' 
            ? entries 
            : entries.filter(e => e.tags.some(t => t.text === currentFilter));

        if (filteredEntries.length === 0) {
            list.innerHTML = "<div class='empty-state'>üîç No vocabulary entries found.</div>";
            return;
        }

        filteredEntries.forEach((e) => {
            const originalIndex = entries.indexOf(e);
            const div = document.createElement("div");
            div.className = "item";
            div.id = `item-${originalIndex}`;
            
            const tagsHtml = e.tags && e.tags.length > 0
                ? e.tags.map(t => `<span class="tag ${t.color}">${escapeHtml(t.text)}</span>`).join('')
                : '';
            
            div.innerHTML = `
                <span>
                    <span class="term">${escapeHtml(e.term)}</span> : ${escapeHtml(e.translation)}
                    ${tagsHtml}
                </span>
                <div class="button-group">
                    <button class="edit-btn" onclick="editItem(${originalIndex})">‚úèÔ∏è</button>
                    <button onclick="deleteItem(${originalIndex})">üóëÔ∏è</button>
                </div>
            `;
            list.appendChild(div);
        });
    }
    
    function renderFilters() {
        const filterContainer = document.getElementById("filterContainer");
        const uniqueTags = new Map();
        entries.forEach(e => {
            if (e.tags) {
                e.tags.forEach(t => {
                     if (!uniqueTags.has(t.text)) {
                         uniqueTags.set(t.text, t.color);
                     }
                });
            }
        });
        
        if (uniqueTags.size === 0) {
            filterContainer.innerHTML = "";
            return;
        }
        
        filterContainer.innerHTML = "";
        const allDiv = document.createElement("div");
        allDiv.className = `filter-tag all ${currentFilter === 'all' ? 'active' : ''}`;
        allDiv.textContent = `All (${entries.length})`;
        allDiv.onclick = () => filterByTag('all');
        filterContainer.appendChild(allDiv);

        if (currentFilter !== 'all') {
            const editControl = document.createElement("div");
            editControl.textContent = "‚úèÔ∏è";
            editControl.style.cursor = "pointer";
            editControl.style.padding = "6px 14px";
            editControl.style.borderRadius = "20px";
            editControl.style.fontSize = "13px";
            editControl.style.fontWeight = "600";
            editControl.onclick = () => beginTagInlineEdit();
            filterContainer.appendChild(editControl);
        }
        
        uniqueTags.forEach((color, tag) => {
            const count = entries.filter(e => e.tags.some(t => t.text === tag)).length;
            if (currentFilter === tag && tagEditMode) {
                const editDiv = document.createElement("div");
                editDiv.className = `filter-tag ${color} active`;
                const input = document.createElement("input");
                input.id = "tagEditInline";
                input.value = tag;
                input.style.padding = "6px 10px";
                input.style.borderRadius = "12px";
                input.style.border = "2px solid white";
                input.style.fontWeight = "600";
                input.style.fontSize = "13px";
                input.onkeydown = (e) => {
                    if (e.key === "Enter") {
                        e.preventDefault();
                        commitTagInlineEdit();
                    } else if (e.key === "Escape") {
                        e.preventDefault();
                        cancelTagInlineEdit();
                    }
                };
                input.onblur = () => {
                    if (tagEditSuppressBlurCommit) {
                        tagEditSuppressBlurCommit = false;
                        setTimeout(() => input.focus(), 0);
                        return;
                    }
                    commitTagInlineEdit();
                };
                const colorPicker = document.createElement("div");
                colorPicker.className = "color-picker";
                // Inline color picker style tweak for compactness
                colorPicker.style.display = "inline-flex"; 
                colorPicker.style.marginLeft = "8px";
                colorPicker.style.padding = "0";
                colorPicker.style.background = "transparent";
                
                const colors = ["blue","red","green","yellow","purple","orange","pink","teal"];
                colors.forEach(c => {
                    const opt = document.createElement("div");
                    opt.className = "color-option " + c + (tagEditSelectedColor === c ? " selected" : "");
                    // Make them smaller for inline
                    opt.style.width = "20px";
                    opt.style.height = "20px";
                    opt.style.borderWidth = "2px";
                    
                    opt.onmousedown = (e) => {
                        e.preventDefault();
                        tagEditSuppressBlurCommit = true;
                    };
                    opt.onclick = () => {
                        tagEditSelectedColor = c;
                        Array.from(colorPicker.querySelectorAll(".color-option")).forEach(o => o.classList.remove("selected"));
                        opt.classList.add("selected");
                        tagEditSuppressBlurCommit = false;
                        input.focus();
                    };
                    colorPicker.appendChild(opt);
                });
                editDiv.appendChild(input);
                editDiv.appendChild(colorPicker);
                filterContainer.appendChild(editDiv);
                setTimeout(() => input.focus(), 0);
            } else {
                const filterDiv = document.createElement("div");
                filterDiv.className = `filter-tag ${color} ${currentFilter === tag ? 'active' : ''}`;
                filterDiv.textContent = `${tag} (${count})`;
                filterDiv.onclick = () => filterByTag(tag);
                filterContainer.appendChild(filterDiv);
            }
        });
    }
    
    function filterByTag(tag) {
        currentFilter = tag;
        renderList();
        renderFilters();
    }
    
    function selectColor(color) {
        selectedColor = color;
        
        // Update UI
        document.querySelectorAll('.color-option').forEach(option => {
            option.classList.remove('selected');
        });
        document.querySelector(`.color-option[data-color="${color}"]`).classList.add('selected');
    }
    
    function renameTag(oldTag, newTag, newColor) {
        entries.forEach(e => {
            if (e.tags) {
                e.tags.forEach(t => {
                    if (t.text === oldTag) {
                        t.text = newTag;
                        t.color = newColor;
                    }
                });
            }
        });
        
        if (currentFilter === oldTag) currentFilter = newTag;
        
        // Update active tags in edit mode too
        currentEntryTags.forEach(t => {
            if (t.text === oldTag) {
                t.text = newTag;
                t.color = newColor;
            }
        });
        renderActiveTags();
        
        entries.sort((a, b) => a.term.localeCompare(b.term));
        saveEntries();
        renderList();
        renderFilters();
        handleTagSearch();
    }
    
    let tagEditMode = false;
    function beginTagInlineEdit() {
        if (currentFilter === 'all') return;
        let foundColor = 'blue';
        for (const e of entries) {
            const t = e.tags.find(t => t.text === currentFilter);
            if (t) {
                foundColor = t.color;
                break;
            }
        }
        tagEditSelectedColor = foundColor;
        tagEditMode = true;
        renderFilters();
    }
    function commitTagInlineEdit() {
        const input = document.getElementById("tagEditInline");
        if (!input) { tagEditMode = false; renderFilters(); return; }
        const newTag = input.value.trim();
        if (!newTag) { tagEditMode = false; renderFilters(); return; }
        const oldTag = currentFilter;
        const newColor = tagEditSelectedColor || 'blue';
        tagEditMode = false;
        renameTag(oldTag, newTag, newColor);
    }
    function cancelTagInlineEdit() {
        tagEditMode = false;
        renderFilters();
    }
    
    function handleTagSearch() {
        const rawValue = document.getElementById("tagInput").value;
        const parts = rawValue.split(',');
        const searchTerm = parts[parts.length - 1].trim().toLowerCase();
        const dropdown = document.getElementById("tagDropdown");
        
        if (!searchTerm) {
            dropdown.style.display = "none";
            tagDropdownIndex = -1;
            return;
        }
        
        // Get unique tags with their colors
        const uniqueTags = new Map();
        entries.forEach(e => {
            if (e.tags) {
                e.tags.forEach(t => {
                     if (!uniqueTags.has(t.text)) {
                         uniqueTags.set(t.text, t.color);
                     }
                });
            }
        });
        
        // Filter tags that match search
        const matches = Array.from(uniqueTags.entries()).filter(([tag]) => 
            tag.toLowerCase().includes(searchTerm)
        );
        
        if (matches.length === 0) {
            dropdown.style.display = "none";
            tagDropdownIndex = -1;
            return;
        }
        
        dropdown.innerHTML = "";
        tagDropdownIndex = -1;
        matches.forEach(([tag, color]) => {
            const div = document.createElement("div");
            div.className = "tag-dropdown-item";
            
            // Create mini color indicator
            const miniTag = document.createElement("span");
            miniTag.className = `mini-tag ${color}`;
            miniTag.style.background = getComputedStyle(document.querySelector(`.color-option.${color}`)).background;
            
            div.appendChild(miniTag);
            div.appendChild(document.createTextNode(tag));
            
            div.onmousedown = (e) => {
                e.preventDefault();
                const currentVal = document.getElementById("tagInput").value;
                const currentParts = currentVal.split(',');
                if (currentParts.length > 1) {
                    addTag(currentParts.slice(0, -1).join(','));
                }
                addTag(tag, color);
                dropdown.style.display = "none";
            };
            dropdown.appendChild(div);
        });
        
        dropdown.style.display = "block";
    }
    
    function hideTagDropdown() {
        setTimeout(() => {
            document.getElementById("tagDropdown").style.display = "none";
            tagDropdownIndex = -1;
        }, 200);
    }
    
    function exportVocabulary() {
        if (entries.length === 0) {
            showImportStatus('No vocabulary entries to export!', 'error');
            return;
        }
        
        const dataStr = JSON.stringify(entries, null, 2);
        const dataBlob = new Blob([dataStr], { type: 'application/json' });
        const url = URL.createObjectURL(dataBlob);
        const link = document.createElement('a');
        link.href = url;
        link.download = "backup_" + new Date().toISOString().replace(/[:T]/g, "-").split(".")[0] + ".json";
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
        
        showImportStatus(`‚úì Exported ${entries.length} entries successfully!`, 'success');
    }
    
    let pendingCollisions = [];
    let currentCollisionIndex = -1;
    let importStats = { added: 0, skipped: 0, overwritten: 0, both: 0 };

    function importVocabulary(event) {
        const file = event.target.files[0];
        if (!file) return;
        
        const reader = new FileReader();
        reader.onload = function(e) {
            try {
                const importedData = JSON.parse(e.target.result);
                
                if (!Array.isArray(importedData)) {
                    showImportStatus('Invalid file format. Expected JSON array.', 'error');
                    return;
                }
                
                pendingCollisions = [];
                importStats = { added: 0, skipped: 0, overwritten: 0, both: 0 };
                
                importedData.forEach(item => {
                    if (item.term && item.translation) {
                        // Normalize tags
                        let tags = [];
                        if (item.tags) {
                            tags = item.tags;
                        } else if (item.tag) {
                            tags = [{ text: item.tag, color: item.color || 'blue' }];
                        }

                        const newItem = {
                            term: item.term,
                            translation: item.translation,
                            tags: tags
                        };
                        
                        // Check for existing term (case-insensitive)
                        const existingIndex = entries.findIndex(e => e.term.toLowerCase() === newItem.term.toLowerCase());
                        
                        if (existingIndex !== -1) {
                            const existing = entries[existingIndex];
                            
                            // Check for exact identity
                            const sameTerm = existing.term === newItem.term;
                            const sameTrans = existing.translation === newItem.translation;
                            
                            const existingTags = existing.tags ? existing.tags.map(t => t.text).sort().join('|') : '';
                            const newTags = newItem.tags ? newItem.tags.map(t => t.text).sort().join('|') : '';
                            const sameTags = existingTags === newTags;

                            if (sameTerm && sameTrans && sameTags) {
                                // Exact duplicate. Keep existing (skip).
                                importStats.skipped++;
                            } else {
                                // Collision
                                pendingCollisions.push({ newItem, existingIndex });
                            }
                        } else {
                            // New item
                            entries.push(newItem);
                            importStats.added++;
                        }
                    }
                });
                
                if (pendingCollisions.length > 0) {
                    currentCollisionIndex = 0;
                    showNextCollision();
                } else {
                    finishImport();
                }

            } catch (error) {
                console.error(error);
                showImportStatus('Error reading file. Please ensure it\'s a valid JSON file.', 'error');
            }
        };
        
        reader.readAsText(file);
        event.target.value = ''; // Reset input
    }
    
    function showNextCollision() {
        const modal = document.getElementById('collisionModal');
        const collision = pendingCollisions[currentCollisionIndex];
        const existing = entries[collision.existingIndex];
        const newItem = collision.newItem;

        document.getElementById('collisionTerm').textContent = existing.term;
        document.getElementById('existingEntryDetails').innerHTML = formatEntryDetails(existing);
        document.getElementById('newEntryDetails').innerHTML = formatEntryDetails(newItem);
        
        document.getElementById('conflictCount').textContent = currentCollisionIndex + 1;
        document.getElementById('conflictTotal').textContent = pendingCollisions.length;

        modal.style.display = 'flex';
    }

    function formatEntryDetails(entry) {
        const tagsHtml = entry.tags && entry.tags.length > 0 
            ? entry.tags.map(t => `<span class="tag ${t.color}" style="font-size:12px;padding:2px 6px;">${escapeHtml(t.text)}</span>`).join(' ')
            : '<span style="color:#999;font-style:italic">No tags</span>';
            
        return `
            <div class="comp-field">
                <div class="comp-label">Term</div>
                <div class="comp-value">${escapeHtml(entry.term)}</div>
            </div>
            <div class="comp-field">
                <div class="comp-label">Translation</div>
                <div class="comp-value">${escapeHtml(entry.translation)}</div>
            </div>
            <div class="comp-field">
                <div class="comp-label">Tags</div>
                <div class="comp-value">${tagsHtml}</div>
            </div>
        `;
    }

    function resolveCollision(action) {
        const collision = pendingCollisions[currentCollisionIndex];
        
        if (action === 'overwrite') {
            // Replace existing
            entries[collision.existingIndex] = collision.newItem;
            importStats.overwritten++;
        } else if (action === 'keepBoth') {
            // Add as new
            entries.push(collision.newItem);
            importStats.both++;
        } else {
            // Skip (keep existing)
            importStats.skipped++;
        }

        currentCollisionIndex++;
        if (currentCollisionIndex < pendingCollisions.length) {
            showNextCollision();
        } else {
            document.getElementById('collisionModal').style.display = 'none';
            finishImport();
        }
    }

    function finishImport() {
        entries.sort((a, b) => a.term.localeCompare(b.term));
        saveEntries();
        renderList();
        renderFilters();
        
        const parts = [];
        if (importStats.added > 0) parts.push(`${importStats.added} added`);
        if (importStats.overwritten > 0) parts.push(`${importStats.overwritten} updated`);
        if (importStats.both > 0) parts.push(`${importStats.both} kept as duplicate`);
        if (importStats.skipped > 0) parts.push(`${importStats.skipped} skipped`);
        
        const msg = parts.length > 0 ? `Import complete: ${parts.join(', ')}` : "Import complete: No changes made.";
        showImportStatus(msg, 'success');
    }
    
    function showImportStatus(message, type) {
        const statusDiv = document.getElementById('importStatus');
        statusDiv.textContent = message;
        statusDiv.className = `import-status ${type}`;
        
        setTimeout(() => {
            statusDiv.className = 'import-status';
        }, 5000);
    }

    function handleTermInput() {
        const searchTerm = document.getElementById("termInput").value.trim().toLowerCase();
        const dropdown = document.getElementById("dropdown");
        
        if (!searchTerm) {
            dropdown.style.display = "none";
            termMatches = [];
            termDropdownIndex = -1;
            return;
        }

        const matches = entries.filter(e => 
            e.term.toLowerCase().includes(searchTerm) || 
            e.translation.toLowerCase().includes(searchTerm)
        );

        dropdown.innerHTML = "";

        if (matches.length === 0) {
            dropdown.style.display = "none";
            termMatches = [];
            termDropdownIndex = -1;
            return;
        }

        termMatches = matches;
        termDropdownIndex = -1;
        matches.forEach(match => {
            const div = document.createElement("div");
            div.className = "dropdown-item";
            div.innerHTML = `<span class="match-term">${escapeHtml(match.term)}</span><span class="match-translation">‚Äî ${escapeHtml(match.translation)}</span>`;
            div.onmousedown = (e) => {
                e.preventDefault();
                const itemIndex = entries.findIndex(entry => 
                    entry.term === match.term && entry.translation === match.translation
                );
                if (itemIndex !== -1) {
                    editItem(itemIndex);
                    document.getElementById("translationInput").focus();
                }
                dropdown.style.display = "none";
            };
            dropdown.appendChild(div);
        });

        dropdown.style.display = "block";
    }

    function hideDropdown() {
        setTimeout(() => {
            document.getElementById("dropdown").style.display = "none";
            termMatches = [];
            termDropdownIndex = -1;
        }, 200);
    }

    function handleTranslationInput() {
        const searchTerm = document.getElementById("translationInput").value.trim().toLowerCase();
        const dropdown = document.getElementById("translationDropdown");
        if (!searchTerm) {
            dropdown.style.display = "none";
            translationMatches = [];
            translationDropdownIndex = -1;
            return;
        }
        const matches = entries.filter(e =>
            e.translation.toLowerCase().includes(searchTerm) ||
            e.term.toLowerCase().includes(searchTerm)
        );
        dropdown.innerHTML = "";
        if (matches.length === 0) {
            dropdown.style.display = "none";
            translationMatches = [];
            translationDropdownIndex = -1;
            return;
        }
        translationMatches = matches;
        translationDropdownIndex = -1;
        matches.forEach(match => {
            const div = document.createElement("div");
            div.className = "dropdown-item";
            div.innerHTML = `<span class="match-term">${escapeHtml(match.translation)}</span><span class="match-translation">‚Äî ${escapeHtml(match.term)}</span>`;
            div.onmousedown = (e) => {
                e.preventDefault();
                const itemIndex = entries.findIndex(entry =>
                    entry.term === match.term && entry.translation === match.translation
                );
                if (itemIndex !== -1) {
                    editItem(itemIndex);
                    document.getElementById("tagInput").focus();
                }
                dropdown.style.display = "none";
            };
            dropdown.appendChild(div);
        });
        dropdown.style.display = "block";
    }
    
    function hideTranslationDropdown() {
        setTimeout(() => {
            document.getElementById("translationDropdown").style.display = "none";
            translationMatches = [];
            translationDropdownIndex = -1;
        }, 200);
    }
    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    function handleKeyPress(event) {
        if (event.key === "Enter") {
            event.preventDefault();
            const dropdown = document.getElementById("dropdown");
            const translationDropdown = document.getElementById("translationDropdown");
            const tagDropdown = document.getElementById("tagDropdown");
            if (dropdown.style.display === "block" || translationDropdown.style.display === "block" || tagDropdown.style.display === "block") {
                return;
            }
            
            if (document.activeElement === document.getElementById("tagInput")) {
                 const val = document.getElementById("tagInput").value.trim();
                 if (val) {
                     addTag();
                     return;
                 }
            }
            
            addItem();
        }
    }

    function highlightItem(index) {
        // Remove previous highlights
        document.querySelectorAll('.item').forEach(item => {
            item.classList.remove('highlight');
        });
        
        // Highlight the selected item
        const itemElement = document.getElementById(`item-${index}`);
        if (itemElement) {
            itemElement.classList.add('highlight');
            itemElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
            
            // Remove highlight after 3 seconds
            setTimeout(() => {
                itemElement.classList.remove('highlight');
            }, 3000);
        }
    }

    // Set up term input listeners
    document.getElementById("termInput").addEventListener("input", handleTermInput);
    document.getElementById("termInput").addEventListener("focus", handleTermInput);
    document.getElementById("termInput").addEventListener("blur", hideDropdown);
    document.getElementById("termInput").addEventListener("keydown", function(e) {
        const dropdown = document.getElementById("dropdown");
        const items = Array.from(dropdown.querySelectorAll(".dropdown-item"));
        if (e.key === "ArrowDown") {
            if (dropdown.style.display === "block" && termMatches.length > 0) {
                e.preventDefault();
                termDropdownIndex = Math.min(termDropdownIndex + 1, termMatches.length - 1);
                items.forEach(i => i.classList.remove("active"));
                if (termDropdownIndex >= 0) items[termDropdownIndex].classList.add("active");
            }
        } else if (e.key === "ArrowUp") {
            if (dropdown.style.display === "block" && termMatches.length > 0) {
                e.preventDefault();
                termDropdownIndex = Math.max(termDropdownIndex - 1, -1);
                items.forEach(i => i.classList.remove("active"));
                if (termDropdownIndex >= 0) items[termDropdownIndex].classList.add("active");
            }
        } else if (e.key === "Enter") {
            if (dropdown.style.display === "block" && termMatches.length > 0 && termDropdownIndex >= 0) {
                e.preventDefault();
                const match = termMatches[termDropdownIndex];
                const itemIndex = entries.findIndex(entry => 
                    entry.term === match.term && entry.translation === match.translation
                );
                if (itemIndex !== -1) {
                    editItem(itemIndex);
                    document.getElementById("translationInput").focus();
                }
                dropdown.style.display = "none";
            }
        } else if (e.key === "Tab") {
            e.preventDefault();
            dropdown.style.display = "none";
            termMatches = [];
            termDropdownIndex = -1;
            document.getElementById("translationInput").focus();
        }
    });
    document.getElementById("translationInput").addEventListener("input", handleTranslationInput);
    document.getElementById("translationInput").addEventListener("focus", handleTranslationInput);
    document.getElementById("translationInput").addEventListener("blur", hideTranslationDropdown);
    document.getElementById("translationInput").addEventListener("keydown", function(e) {
        const dropdown = document.getElementById("translationDropdown");
        const items = Array.from(dropdown.querySelectorAll(".dropdown-item"));
        if (e.key === "ArrowDown") {
            if (dropdown.style.display === "block" && translationMatches.length > 0) {
                e.preventDefault();
                translationDropdownIndex = Math.min(translationDropdownIndex + 1, translationMatches.length - 1);
                items.forEach(i => i.classList.remove("active"));
                if (translationDropdownIndex >= 0) items[translationDropdownIndex].classList.add("active");
            }
        } else if (e.key === "ArrowUp") {
            if (dropdown.style.display === "block" && translationMatches.length > 0) {
                e.preventDefault();
                translationDropdownIndex = Math.max(translationDropdownIndex - 1, -1);
                items.forEach(i => i.classList.remove("active"));
                if (translationDropdownIndex >= 0) items[translationDropdownIndex].classList.add("active");
            }
        } else if (e.key === "Enter") {
            if (dropdown.style.display === "block" && translationMatches.length > 0 && translationDropdownIndex >= 0) {
                e.preventDefault();
                const match = translationMatches[translationDropdownIndex];
                const itemIndex = entries.findIndex(entry =>
                    entry.term === match.term && entry.translation === match.translation
                );
                if (itemIndex !== -1) {
                    editItem(itemIndex);
                    document.getElementById("tagInput").focus();
                }
                dropdown.style.display = "none";
            }
        } else if (e.key === "Tab") {
            e.preventDefault();
            dropdown.style.display = "none";
            translationMatches = [];
            translationDropdownIndex = -1;
            document.getElementById("tagInput").focus();
        }
    });
    document.getElementById("tagInput").addEventListener("keydown", function(e) {
        const dropdown = document.getElementById("tagDropdown");
        const items = Array.from(dropdown.querySelectorAll(".tag-dropdown-item"));
        if (e.key === "ArrowDown") {
            if (dropdown.style.display === "block" && items.length > 0) {
                e.preventDefault();
                tagDropdownIndex = Math.min(tagDropdownIndex + 1, items.length - 1);
                items.forEach(i => i.classList.remove("active"));
                if (tagDropdownIndex >= 0) items[tagDropdownIndex].classList.add("active");
            }
        } else if (e.key === "ArrowUp") {
            if (dropdown.style.display === "block" && items.length > 0) {
                e.preventDefault();
                tagDropdownIndex = Math.max(tagDropdownIndex - 1, -1);
                items.forEach(i => i.classList.remove("active"));
                if (tagDropdownIndex >= 0) items[tagDropdownIndex].classList.add("active");
            }
        } else if (e.key === "Enter") {
            if (dropdown.style.display === "block" && items.length > 0 && tagDropdownIndex >= 0) {
                e.preventDefault();
                const item = items[tagDropdownIndex];
                const tag = item.textContent.trim();
                const miniTag = item.querySelector(".mini-tag");
                // Extract color from class list (assumes "mini-tag {color}")
                let color = 'blue';
                if (miniTag.classList.length > 1) {
                    color = miniTag.classList[1];
                }
                
                const currentVal = document.getElementById("tagInput").value;
                const currentParts = currentVal.split(',');
                if (currentParts.length > 1) {
                    addTag(currentParts.slice(0, -1).join(','));
                }
                
                addTag(tag, color);
                dropdown.style.display = "none";
                document.querySelector('button[onclick="addItem()"]').focus();
            }
        } else if (e.key === "Tab") {
            e.preventDefault();
            dropdown.style.display = "none";
            tagMatches = [];
            tagDropdownIndex = -1;
            document.querySelector('button[onclick="addItem()"]').focus();
        }
    });

    // Load entries on start
    loadEntries();
    loadTheme();
    renderFilters();
    
    function toggleTheme() {
        const body = document.body;
        const themeToggle = document.querySelector('.theme-toggle');
        
        body.classList.toggle('night-mode');
        
        if (body.classList.contains('night-mode')) {
            themeToggle.textContent = '‚òÄÔ∏è';
            localStorage.setItem('theme', 'night');
        } else {
            themeToggle.textContent = 'üåô';
            localStorage.setItem('theme', 'day');
        }
    }
    
    function loadTheme() {
        const savedTheme = localStorage.getItem('theme');
        const body = document.body;
        const themeToggle = document.querySelector('.theme-toggle');
        
        if (savedTheme === 'night') {
            body.classList.add('night-mode');
            themeToggle.textContent = '‚òÄÔ∏è';
        }
    }
</script>

<div id="collisionModal" class="modal-overlay">
    <div class="modal">
        <h3>Import Conflict Detected</h3>
        <p style="margin-top: 8px; opacity: 0.8; font-size: 14px;">
            An entry with the term "<span id="collisionTerm" style="font-weight:bold"></span>" already exists but has different details.
        </p>
        
        <div class="comparison-grid">
            <div class="comparison-col">
                <h4>Existing Entry</h4>
                <div class="comparison-box" id="existingEntryDetails">
                    <!-- populated by js -->
                </div>
            </div>
            <div class="comparison-col">
                <h4>New Entry</h4>
                <div class="comparison-box" id="newEntryDetails">
                    <!-- populated by js -->
                </div>
            </div>
        </div>
        
        <div class="modal-actions">
            <button class="btn-secondary" onclick="resolveCollision('skip')">Keep Existing</button>
            <button onclick="resolveCollision('keepBoth')">Keep Both</button>
            <button class="btn-danger" onclick="resolveCollision('overwrite')">Overwrite</button>
        </div>
        <div style="text-align: center; margin-top: 10px; font-size: 12px; opacity: 0.6;">
            Conflict <span id="conflictCount">1</span> of <span id="conflictTotal">1</span>
        </div>
    </div>
</div>

</body>
</html>
